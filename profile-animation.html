<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Profile Animation</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      overflow: hidden;
      background: #000000;
      font-family: 'Courier New', monospace;
    }

    #canvas-container {
      width: 100%;
      height: 600px;
      position: relative;
      background: linear-gradient(180deg, #000000 0%, #0a0a0a 50%, #000000 100%);
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    .scene-indicator {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      z-index: 10;
    }

    .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      transition: all 0.3s ease;
      box-shadow: 0 0 5px rgba(0, 255, 255, 0.3);
    }

    .dot.active {
      background: #00ffff;
      box-shadow: 0 0 15px #00ffff, 0 0 30px rgba(0, 255, 255, 0.5);
      transform: scale(1.3);
    }

    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #00ffff;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 3px;
      text-shadow: 0 0 10px #00ffff;
    }
  </style>
</head>
<body>
  <div id="canvas-container">
    <div id="loading">Initializing...</div>
    <div class="scene-indicator">
      <div class="dot active"></div>
      <div class="dot"></div>
      <div class="dot"></div>
      <div class="dot"></div>
      <div class="dot"></div>
      <div class="dot"></div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Scene setup
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.002);

    const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.z = 50;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setClearColor(0x000000, 1);
    container.appendChild(renderer.domElement);

    // Colors
    const neonRed = 0xff0040;
    const neonBlue = 0x00ffff;

    // Scene management
    let currentScene = 0;
    let sceneObjects = [];
    let transitionProgress = 0;
    const sceneDuration = 4000; // 4 seconds per scene
    const transitionDuration = 1000; // 1 second transition
    let lastSceneChange = Date.now();

    // Scene 1: Starfield with orbiting particles (Universe/Stargazing)
    function createStarfield() {
      const group = new THREE.Group();
      const starGeometry = new THREE.BufferGeometry();
      const starCount = 2000;
      const positions = new Float32Array(starCount * 3);

      for (let i = 0; i < starCount * 3; i += 3) {
        positions[i] = (Math.random() - 0.5) * 200;
        positions[i + 1] = (Math.random() - 0.5) * 200;
        positions[i + 2] = (Math.random() - 0.5) * 200;
      }

      starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const starMaterial = new THREE.PointsMaterial({
        color: neonBlue,
        size: 0.5,
        transparent: true,
        opacity: 0.8
      });

      const stars = new THREE.Points(starGeometry, starMaterial);
      group.add(stars);

      // Orbiting planets
      for (let i = 0; i < 5; i++) {
        const radius = 0.5 + Math.random() * 1.5;
        const geometry = new THREE.SphereGeometry(radius, 16, 16);
        const material = new THREE.MeshBasicMaterial({
          color: i % 2 === 0 ? neonRed : neonBlue,
          wireframe: true,
          transparent: true,
          opacity: 0.6
        });
        const planet = new THREE.Mesh(geometry, material);
        
        planet.userData.orbitRadius = 15 + i * 8;
        planet.userData.orbitSpeed = 0.0002 + Math.random() * 0.0003;
        planet.userData.angle = Math.random() * Math.PI * 2;
        
        group.add(planet);
      }

      return group;
    }

    // Scene 2: Crystalline structures (Materials Science)
    function createCrystalStructure() {
      const group = new THREE.Group();
      
      // Central crystal cluster
      for (let i = 0; i < 12; i++) {
        const size = 3 + Math.random() * 4;
        const geometry = new THREE.OctahedronGeometry(size, 0);
        const material = new THREE.MeshBasicMaterial({
          color: i % 2 === 0 ? neonRed : neonBlue,
          wireframe: true,
          transparent: true,
          opacity: 0.7
        });
        const crystal = new THREE.Mesh(geometry, material);
        
        crystal.position.set(
          (Math.random() - 0.5) * 20,
          (Math.random() - 0.5) * 20,
          (Math.random() - 0.5) * 20
        );
        crystal.rotation.set(
          Math.random() * Math.PI,
          Math.random() * Math.PI,
          Math.random() * Math.PI
        );
        crystal.userData.rotationSpeed = {
          x: (Math.random() - 0.5) * 0.01,
          y: (Math.random() - 0.5) * 0.01,
          z: (Math.random() - 0.5) * 0.01
        };
        
        group.add(crystal);
      }

      // Connecting lines
      const lineGeometry = new THREE.BufferGeometry();
      const linePositions = [];
      const children = group.children;
      
      for (let i = 0; i < children.length; i++) {
        for (let j = i + 1; j < children.length; j++) {
          if (children[i].position.distanceTo(children[j].position) < 15) {
            linePositions.push(children[i].position.x, children[i].position.y, children[i].position.z);
            linePositions.push(children[j].position.x, children[j].position.y, children[j].position.z);
          }
        }
      }
      
      lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));
      const lineMaterial = new THREE.LineBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.2
      });
      const lines = new THREE.LineSegments(lineGeometry, lineMaterial);
      group.add(lines);

      return group;
    }

    // Scene 3: Code Matrix (Self-taught Coder)
    function createCodeMatrix() {
      const group = new THREE.Group();
      const columns = 30;
      const rows = 20;
      
      for (let i = 0; i < columns; i++) {
        for (let j = 0; j < rows; j++) {
          const geometry = new THREE.PlaneGeometry(1, 1);
          const material = new THREE.MeshBasicMaterial({
            color: Math.random() > 0.5 ? neonBlue : neonRed,
            transparent: true,
            opacity: Math.random() * 0.5 + 0.2,
            side: THREE.DoubleSide
          });
          const plane = new THREE.Mesh(geometry, material);
          
          plane.position.set(
            (i - columns / 2) * 2.5,
            (j - rows / 2) * 2.5,
            (Math.random() - 0.5) * 30
          );
          
          plane.userData.fallSpeed = 0.05 + Math.random() * 0.1;
          plane.userData.resetY = (rows / 2) * 2.5;
          
          group.add(plane);
        }
      }

      return group;
    }

    // Scene 4: Neural Network (AI/Automation)
    function createNeuralNetwork() {
      const group = new THREE.Group();
      const layers = 4;
      const nodesPerLayer = 8;
      const nodes = [];

      // Create nodes
      for (let layer = 0; layer < layers; layer++) {
        for (let i = 0; i < nodesPerLayer; i++) {
          const geometry = new THREE.SphereGeometry(0.5, 16, 16);
          const material = new THREE.MeshBasicMaterial({
            color: layer % 2 === 0 ? neonRed : neonBlue,
            transparent: true,
            opacity: 0.8
          });
          const node = new THREE.Mesh(geometry, material);
          
          node.position.set(
            (layer - layers / 2) * 15,
            (i - nodesPerLayer / 2) * 4,
            0
          );
          
          node.userData.pulse = Math.random() * Math.PI * 2;
          nodes.push(node);
          group.add(node);
        }
      }

      // Create connections
      for (let i = 0; i < nodes.length - nodesPerLayer; i++) {
        if (Math.floor(i / nodesPerLayer) < layers - 1) {
          for (let j = 0; j < nodesPerLayer; j++) {
            if (Math.random() > 0.4) {
              const targetIndex = i + nodesPerLayer + j;
              if (targetIndex < nodes.length) {
                const geometry = new THREE.BufferGeometry().setFromPoints([
                  nodes[i].position,
                  nodes[targetIndex].position
                ]);
                const material = new THREE.LineBasicMaterial({
                  color: 0xffffff,
                  transparent: true,
                  opacity: 0.15
                });
                const line = new THREE.Line(geometry, material);
                group.add(line);
              }
            }
          }
        }
      }

      group.userData.nodes = nodes;
      return group;
    }

    // Scene 5: Floating Books (boighorlibrary.com)
    function createBookLibrary() {
      const group = new THREE.Group();
      
      for (let i = 0; i < 20; i++) {
        const width = 1.5 + Math.random() * 1;
        const height = 2 + Math.random() * 1;
        const depth = 0.3;
        
        const geometry = new THREE.BoxGeometry(width, height, depth);
        const material = new THREE.MeshBasicMaterial({
          color: i % 3 === 0 ? neonRed : i % 3 === 1 ? neonBlue : 0xffffff,
          wireframe: true,
          transparent: true,
          opacity: 0.6
        });
        const book = new THREE.Mesh(geometry, material);
        
        const radius = 15 + Math.random() * 15;
        const angle = (i / 20) * Math.PI * 2;
        const y = (Math.random() - 0.5) * 20;
        
        book.position.set(
          Math.cos(angle) * radius,
          y,
          Math.sin(angle) * radius
        );
        
        book.rotation.set(
          Math.random() * Math.PI,
          Math.random() * Math.PI,
          Math.random() * Math.PI
        );
        
        book.userData.orbitSpeed = 0.0001 + Math.random() * 0.0002;
        book.userData.angle = angle;
        book.userData.radius = radius;
        book.userData.rotationSpeed = {
          x: (Math.random() - 0.5) * 0.01,
          y: (Math.random() - 0.5) * 0.01,
          z: (Math.random() - 0.5) * 0.01
        };
        
        group.add(book);
      }

      return group;
    }

    // Scene 6: Game Grid (Game Making)
    function createGameGrid() {
      const group = new THREE.Group();
      const gridSize = 12;
      
      for (let x = 0; x < gridSize; x++) {
        for (let z = 0; z < gridSize; z++) {
          const height = Math.random() * 5 + 1;
          const geometry = new THREE.BoxGeometry(1.5, height, 1.5);
          const material = new THREE.MeshBasicMaterial({
            color: (x + z) % 2 === 0 ? neonRed : neonBlue,
            wireframe: true,
            transparent: true,
            opacity: 0.7
          });
          const cube = new THREE.Mesh(geometry, material);
          
          cube.position.set(
            (x - gridSize / 2) * 2,
            -height / 2,
            (z - gridSize / 2) * 2
          );
          
          cube.userData.baseHeight = height;
          cube.userData.wave = (x + z) * 0.5;
          
          group.add(cube);
        }
      }

      return group;
    }

    // Initialize all scenes
    const scenes = [
      createStarfield(),
      createCrystalStructure(),
      createCodeMatrix(),
      createNeuralNetwork(),
      createBookLibrary(),
      createGameGrid()
    ];

    scenes.forEach((s, i) => {
      s.visible = i === 0;
      scene.add(s);
    });

    sceneObjects = scenes;

    // Update scene indicators
    function updateIndicators() {
      const dots = document.querySelectorAll('.dot');
      dots.forEach((dot, i) => {
        dot.classList.toggle('active', i === currentScene);
      });
    }

    // Scene transition
    function transitionScene() {
      const now = Date.now();
      if (now - lastSceneChange > sceneDuration) {
        const nextScene = (currentScene + 1) % scenes.length;
        
        // Fade out current, fade in next
        scenes[currentScene].visible = true;
        scenes[nextScene].visible = true;
        
        currentScene = nextScene;
        lastSceneChange = now;
        updateIndicators();
      }
    }

    // Animation updates for each scene
    function animateStarfield(scene, delta) {
      scene.children.forEach(child => {
        if (child.userData.orbitRadius) {
          child.userData.angle += child.userData.orbitSpeed * delta;
          child.position.x = Math.cos(child.userData.angle) * child.userData.orbitRadius;
          child.position.z = Math.sin(child.userData.angle) * child.userData.orbitRadius;
          child.rotation.y += 0.001 * delta;
        }
      });
      scene.rotation.y += 0.00005 * delta;
    }

    function animateCrystalStructure(scene, delta) {
      scene.children.forEach(child => {
        if (child.userData.rotationSpeed) {
          child.rotation.x += child.userData.rotationSpeed.x * delta;
          child.rotation.y += child.userData.rotationSpeed.y * delta;
          child.rotation.z += child.userData.rotationSpeed.z * delta;
        }
      });
      scene.rotation.y += 0.0001 * delta;
    }

    function animateCodeMatrix(scene, delta) {
      scene.children.forEach(child => {
        if (child.userData.fallSpeed) {
          child.position.y -= child.userData.fallSpeed * delta;
          child.material.opacity = Math.abs(Math.sin(child.position.y * 0.1)) * 0.5 + 0.2;
          
          if (child.position.y < -child.userData.resetY) {
            child.position.y = child.userData.resetY;
            child.material.color.setHex(Math.random() > 0.5 ? neonBlue : neonRed);
          }
        }
      });
    }

    function animateNeuralNetwork(scene, delta) {
      if (scene.userData.nodes) {
        scene.userData.nodes.forEach(node => {
          node.userData.pulse += 0.002 * delta;
          const scale = 1 + Math.sin(node.userData.pulse) * 0.3;
          node.scale.set(scale, scale, scale);
        });
      }
      scene.rotation.y += 0.0001 * delta;
    }

    function animateBookLibrary(scene, delta) {
      scene.children.forEach(child => {
        if (child.userData.orbitSpeed) {
          child.userData.angle += child.userData.orbitSpeed * delta;
          child.position.x = Math.cos(child.userData.angle) * child.userData.radius;
          child.position.z = Math.sin(child.userData.angle) * child.userData.radius;
          
          child.rotation.x += child.userData.rotationSpeed.x * delta;
          child.rotation.y += child.userData.rotationSpeed.y * delta;
          child.rotation.z += child.userData.rotationSpeed.z * delta;
        }
      });
    }

    function animateGameGrid(scene, delta) {
      scene.children.forEach(child => {
        if (child.userData.wave !== undefined) {
          const time = Date.now() * 0.001;
          const wave = Math.sin(time + child.userData.wave) * 0.5 + 0.5;
          const newHeight = child.userData.baseHeight * (0.5 + wave * 1.5);
          child.scale.y = newHeight / child.userData.baseHeight;
          child.position.y = -newHeight / 2;
        }
      });
      scene.rotation.y += 0.0002 * delta;
    }

    const animationFunctions = [
      animateStarfield,
      animateCrystalStructure,
      animateCodeMatrix,
      animateNeuralNetwork,
      animateBookLibrary,
      animateGameGrid
    ];

    // Animation loop
    let lastTime = Date.now();
    function animate() {
      requestAnimationFrame(animate);
      
      const currentTime = Date.now();
      const delta = currentTime - lastTime;
      lastTime = currentTime;

      transitionScene();

      // Animate current scene
      if (animationFunctions[currentScene]) {
        animationFunctions[currentScene](scenes[currentScene], delta);
      }

      // Camera gentle movement
      camera.position.x = Math.sin(currentTime * 0.0001) * 5;
      camera.position.y = Math.cos(currentTime * 0.00015) * 3;
      camera.lookAt(0, 0, 0);

      renderer.render(scene, camera);
    }

    // Handle resize
    window.addEventListener('resize', () => {
      const width = container.clientWidth;
      const height = container.clientHeight;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    });

    // Start animation
    document.getElementById('loading').style.display = 'none';
    animate();
  </script>
</body>
</html>